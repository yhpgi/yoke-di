{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Selamat Datang di Yoke DI","text":"<p> Kerangka kerja Dependency Injection (DI) yang ringan, berbasis KSP, dan modern untuk Kotlin Multiplatform &amp; Compose Multiplatform. </p> <p>Yoke DI adalah solusi dependency injection yang dirancang untuk menyederhanakan pengembangan aplikasi Kotlin Multiplatform (KMP). Dengan memanfaatkan kekuatan Kotlin Symbol Processing (KSP), Yoke DI menghasilkan kode DI yang efisien saat compile-time, menghilangkan kebutuhan akan reflection dan memastikan performa maksimal.</p> <p>Terinspirasi dari Dagger/Hilt, Yoke DI membawa konsep-konsep yang sudah terbukti ke dunia KMP dengan API yang lebih sederhana, lebih intuitif, dan terintegrasi secara mendalam dengan Compose Multiplatform.</p>"},{"location":"#mengapa-memilih-yoke-di","title":"Mengapa Memilih Yoke DI?","text":"<ul> <li>\u2705 Sederhana dan Intuitif: Mengurangi boilerplate dan kompleksitas yang sering ditemukan pada kerangka kerja DI lainnya.</li> <li>\u2705 Performa Tinggi: Tidak ada reflection. Semua dependensi diresolusi saat compile-time.</li> <li>\u2705 Benar-benar Multiplatform: Satu set anotasi dan API untuk semua target Anda: Android, iOS (mendatang), Desktop, Web.</li> <li>\u2705 API DSL Modern: Gunakan <code>inject&lt;T&gt;()</code>, <code>injectViewModel&lt;T&gt;()</code>, dan <code>scope&lt;T&gt; {}</code> untuk kode yang lebih bersih dan ekspresif.</li> </ul>"},{"location":"#siap-memulai","title":"Siap Memulai?","text":"<p>Langsung saja ke Panduan Memulai untuk mengintegrasikan Yoke DI ke dalam proyek Anda dalam beberapa menit.</p>"},{"location":"getting-started/","title":"Panduan Memulai","text":"<p>Mengintegrasikan Yoke DI ke dalam proyek Kotlin Multiplatform Anda sangatlah mudah. Ikuti langkah-langkah di bawah ini untuk memulai.</p>"},{"location":"getting-started/#langkah-1-konfigurasi-gradle","title":"Langkah 1: Konfigurasi Gradle","text":"<p>Yoke DI menggunakan KSP (Kotlin Symbol Processing) untuk menghasilkan kode. Anda perlu menambahkan plugin KSP dan dependensi Yoke ke proyek Anda.</p> <p>Status Publikasi</p> <p>Saat ini, Yoke DI belum dipublikasikan ke Maven Central. Panduan ini mengasumsikan Anda telah menyertakan <code>lib-di</code>, <code>lib-di-annotation</code>, dan <code>lib-di-processor</code> sebagai modul lokal di proyek Anda.</p>"},{"location":"getting-started/#1-tambahkan-plugin-ksp","title":"1. Tambahkan Plugin KSP","text":"<p>Pastikan Anda memiliki plugin KSP di file <code>build.gradle.kts</code> level proyek (root).</p> build.gradle.kts (proyek)<pre><code>plugins {\n    alias(libs.plugins.ksp) apply false\n    // ... plugin lainnya\n}\n</code></pre>"},{"location":"getting-started/#2-terapkan-plugin-dan-tambahkan-dependensi","title":"2. Terapkan Plugin dan Tambahkan Dependensi","text":"<p>Di file <code>build.gradle.kts</code> modul common Anda, terapkan plugin KSP dan tambahkan dependensi Yoke.</p> sample/build.gradle.kts (modul)<pre><code>plugins {\n    alias(libs.plugins.multiplatform)\n    alias(libs.plugins.ksp) // Terapkan KSP\n    // ... plugin lainnya\n}\n\nkotlin {\n    // ... konfigurasi KMP Anda\n\n    sourceSets {\n        commonMain.dependencies {\n            implementation(project(\":lib-di-annotation\"))\n            implementation(project(\":lib-di\"))\n        }\n    }\n}\n\nval kspTaskName = \"kspCommonMainKotlinMetadata\"\ntasks.matching { it.name.startsWith(\"ksp\") &amp;&amp; it.name != kspTaskName }.configureEach { dependsOn(kspTaskName) }\n\nkotlin.sourceSets.commonMain {\n     kotlin.srcDir(\"build/generated/ksp/metadata/commonMain/kotlin\")\n}\n\n// Tambahkan prosesor KSP untuk commonMain\ndependencies {\n    add(\"kspCommonMainMetadata\", project(\":lib-di-processor\"))\n}\n</code></pre>"},{"location":"getting-started/#langkah-2-hello-yoke","title":"Langkah 2: \"Hello, Yoke!\"","text":"<p>Mari kita buat contoh DI sederhana.</p>"},{"location":"getting-started/#1-definisikan-komponen-root","title":"1. Definisikan Komponen Root","text":"<p>Komponen adalah inti dari grafik dependensi Anda. Buat sebuah <code>interface</code> dan tandai dengan <code>@YokeComponent</code> dan <code>@YokeEntryPoint</code>.</p> di/AppComponent.kt<pre><code>package io.github.yhpgi.yoke.sample.di\n\nimport io.github.yhpgi.yoke.annotation.*\n\n@YokeEntryPoint\n@Singleton\n@YokeComponent\ninterface AppComponent\n</code></pre> <ul> <li><code>@YokeComponent</code>: Mendefinisikan <code>interface</code> ini sebagai container DI.</li> <li><code>@Singleton</code>: Menetapkan scope default untuk komponen ini.</li> <li><code>@YokeEntryPoint</code>: Memberi tahu Yoke bahwa ini adalah komponen root yang akan digunakan untuk menghasilkan <code>YokeApplication</code>.</li> </ul>"},{"location":"getting-started/#2-buat-dependensi","title":"2. Buat Dependensi","text":"<p>Buat kelas sederhana yang ingin Anda injeksi. Gunakan <code>@Injectable</code> pada konstruktor dan <code>@ContributesTo</code> untuk mendaftarkannya ke komponen.</p> domain/Greeter.kt<pre><code>package io.github.yhpgi.yoke.sample.domain\n\nimport io.github.yhpgi.yoke.annotation.ContributesTo\nimport io.github.yhpgi.yoke.annotation.Injectable\nimport io.github.yhpgi.yoke.sample.di.AppComponent\n\n@Injectable\n@ContributesTo(AppComponent::class)\nclass Greeter {\n    fun greet(): String = \"Hello from Yoke DI!\"\n}\n</code></pre>"},{"location":"getting-started/#3-inisialisasi-dan-injeksi","title":"3. Inisialisasi dan Injeksi","text":"<p>Terakhir, bungkus UI Anda dengan <code>YokeApplication</code> dan gunakan <code>inject&lt;T&gt;()</code> untuk mendapatkan dependensi Anda.</p> App.kt<pre><code>package io.github.yhpgi.yoke.sample\n\nimport androidx.compose.material3.Text\nimport androidx.compose.runtime.Composable\nimport io.github.yhpgi.yoke.di.YokeApplication\nimport io.github.yhpgi.yoke.di.inject\nimport io.github.yhpgi.yoke.sample.domain.Greeter\n\n@Composable\nfun App() {\n    // YokeApplication menginisialisasi DI container\n    YokeApplication {\n        // inject&lt;Greeter&gt;() akan menyediakan instance Greeter\n        val greeter = inject&lt;Greeter&gt;()\n\n        Text(text = greeter.greet())\n    }\n}\n</code></pre>"},{"location":"getting-started/#langkah-3-build-proyek-anda","title":"Langkah 3: Build Proyek Anda","text":"<p>Jalankan build Gradle. KSP akan berjalan dan menghasilkan kode yang diperlukan di direktori <code>build/generated</code>. Setelah build berhasil, aplikasi Anda siap dijalankan dengan Yoke DI!</p> <p>Sekarang Anda siap untuk menjelajahi Konsep Inti Yoke DI lebih dalam.</p>"},{"location":"advanced/android/","title":"Penggunaan Lanjutan: Integrasi Android","text":"<p>Yoke DI menyediakan beberapa fitur khusus untuk menyederhanakan pengembangan di platform Android.</p>"},{"location":"advanced/android/#inisialisasi-otomatis-dengan-yokecontentprovider","title":"Inisialisasi Otomatis dengan <code>YokeContentProvider</code>","text":"<p>Cara termudah untuk menginisialisasi Yoke di Android adalah secara otomatis. Yoke menyediakan <code>ContentProvider</code> internal yang akan menangkap <code>Context</code> aplikasi saat startup.</p> <p>Untuk mengaktifkannya, cukup tambahkan <code>provider</code> ke <code>AndroidManifest.xml</code> Anda.</p> AndroidManifest.xml<pre><code>&lt;manifest ...&gt;\n    &lt;application ...&gt;\n\n        &lt;!-- Yoke Content Provider untuk inisialisasi otomatis --&gt;\n        &lt;provider\n            android:name=\"io.github.yhpgi.yoke.di.YokeContentProvider\"\n            android:authorities=\"${applicationId}.yoke.di.provider\"\n            android:exported=\"false\"\n            android:initOrder=\"101\" /&gt;\n\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Dengan ini, Yoke akan siap untuk injeksi global (<code>injectGlobal</code>) bahkan sebelum UI pertama ditampilkan.</p>"},{"location":"advanced/android/#inisialisasi-manual","title":"Inisialisasi Manual","text":"<p>Jika Anda lebih suka kontrol manual atau tidak dapat menggunakan <code>ContentProvider</code>, Anda bisa menginisialisasi Yoke secara manual di kelas <code>Application</code> Anda.</p> MyApplication.kt<pre><code>import android.app.Application\nimport io.github.yhpgi.yoke.di.AndroidYoke\n\nclass MyApplication : Application() {\n    override fun onCreate() {\n        super.onCreate()\n        AndroidYoke.initialize(this)\n    }\n}\n</code></pre>"},{"location":"advanced/android/#menginjeksi-context","title":"Menginjeksi <code>Context</code>","text":"<p>Seringkali Anda memerlukan <code>Context</code> aplikasi sebagai dependensi (misalnya, untuk mengakses SharedPreferences, database, dll.). Anda bisa menyediakannya melalui modul.</p> di/PlatformModule.android.kt<pre><code>import android.content.Context\nimport io.github.yhpgi.yoke.annotation.ContributesTo\nimport io.github.yhpgi.yoke.annotation.Module\nimport io.github.yhpgi.yoke.annotation.Provides\nimport io.github.yhpgi.yoke.annotation.Singleton\nimport io.github.yhpgi.yoke.di.AndroidYoke\n\n@Module\n@ContributesTo(AppComponent::class)\nobject PlatformModule {\n\n    @Provides\n    @Singleton\n    fun provideApplicationContext(): Context {\n        return AndroidYoke.getApplicationContext()\n    }\n}\n</code></pre> <p>Sekarang Anda bisa menginjeksi <code>Context</code> di mana saja.</p>"},{"location":"advanced/android/#fungsi-ekstensi-contextinjectt","title":"Fungsi Ekstensi <code>Context.inject&lt;T&gt;()</code>","text":"<p>Untuk kenyamanan, Yoke menyediakan fungsi ekstensi pada <code>Context</code> untuk melakukan injeksi global. Ini adalah alternatif dari <code>injectGlobal&lt;T&gt;()</code> yang mungkin terasa lebih alami di lingkungan Android.</p> <pre><code>import io.github.yhpgi.yoke.di.inject\n\nclass MyActivity : AppCompatActivity() {\n    // Injeksi menggunakan context aplikasi\n    private val myRepository: MyRepository by lazy {\n        applicationContext.inject()\n    }\n\n    // Injeksi dengan qualifier\n    private val premiumRepository: UserRepository by lazy {\n        applicationContext.inject {\n            qualifiedBy(PremiumUser::class)\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        // ...\n    }\n}\n</code></pre>"},{"location":"advanced/global-injection/","title":"Penggunaan Lanjutan: Injeksi Non-Composable","text":"<p>Meskipun Yoke DI dirancang dengan mempertimbangkan Compose, ada banyak skenario di mana Anda perlu mengakses dependensi di luar fungsi <code>@Composable</code>. Contohnya termasuk:</p> <ul> <li>Background worker</li> <li>Service</li> <li>Kelas helper atau utilitas</li> <li>Logika bisnis di luar ViewModel</li> </ul> <p>Untuk kasus-kasus ini, Yoke menyediakan fungsi <code>injectGlobal&lt;T&gt;()</code>.</p>"},{"location":"advanced/global-injection/#injectglobalt","title":"<code>injectGlobal&lt;T&gt;()</code>","text":"<p>Fungsi <code>injectGlobal&lt;T&gt;()</code> memungkinkan Anda untuk mendapatkan dependensi dari mana saja di aplikasi Anda, selama grafik dependensi telah diinisialisasi.</p> <p>Prasyarat</p> <p><code>injectGlobal&lt;T&gt;()</code> hanya akan berfungsi setelah Composable <code>YokeApplication</code> telah ditampilkan setidaknya satu kali. Ini karena <code>YokeApplication</code> bertanggung jawab untuk membangun dan menginisialisasi container DI global. Memanggil <code>injectGlobal</code> sebelum itu akan menyebabkan crash.</p>"},{"location":"advanced/global-injection/#penggunaan-dasar","title":"Penggunaan Dasar","text":"<p>Cukup panggil <code>injectGlobal&lt;T&gt;()</code> dengan tipe yang ingin Anda dapatkan.</p> <pre><code>import io.github.yhpgi.yoke.di.injectGlobal\nimport io.github.yhpgi.yoke.sample.domain.AnalyticsService\n\nclass SampleWorker {\n    fun doWork() {\n        // Dapatkan AnalyticsService dari container global\n        val analytics = injectGlobal&lt;AnalyticsService&gt;()\n        analytics.trackEvent(\"Worker task started\")\n    }\n}\n</code></pre>"},{"location":"advanced/global-injection/#penggunaan-dengan-qualifier","title":"Penggunaan dengan Qualifier","text":"<p>Sama seperti <code>inject&lt;T&gt;()</code>, Anda juga dapat menggunakan <code>qualifiedBy</code> untuk mendapatkan implementasi yang spesifik.</p> <pre><code>import io.github.yhpgi.yoke.di.injectGlobal\nimport io.github.yhpgi.yoke.sample.di.PremiumUser\nimport io.github.yhpgi.yoke.sample.domain.UserRepository\n\nclass UserManager {\n    fun getPremiumUser(): String {\n        val premiumRepo = injectGlobal&lt;UserRepository&gt; {\n            qualifiedBy(PremiumUser::class)\n        }\n        return premiumRepo.getUsername()\n    }\n}\n</code></pre> <p>Fungsi <code>injectGlobal&lt;T&gt;()</code> adalah alat yang ampuh untuk mengintegrasikan Yoke DI ke seluruh bagian dari aplikasi Anda, tidak hanya di lapisan UI.</p>"},{"location":"core-concepts/assisted-injection/","title":"Konsep Inti: Assisted Injection","text":"<p>Assisted Injection adalah pola yang berguna ketika sebuah kelas membutuhkan beberapa dependensi dari grafik DI, tetapi juga memerlukan beberapa parameter yang hanya tersedia saat runtime. Ini pada dasarnya adalah cara untuk membuat factory secara otomatis.</p> <p>Misalnya, bayangkan sebuah <code>ListItemFormatter</code> yang membutuhkan <code>AnalyticsService</code> dari DI, tetapi juga <code>id</code> dan <code>prefix</code> item yang akan diformat, yang diberikan saat runtime.</p>"},{"location":"core-concepts/assisted-injection/#assisted","title":"<code>@Assisted</code>","text":"<p>Gunakan anotasi <code>@Assisted</code> untuk menandai parameter di konstruktor <code>@Injectable</code> yang ingin Anda berikan saat runtime.</p> <pre><code>import io.github.yhpgi.yoke.annotation.Assisted\nimport io.github.yhpgi.yoke.annotation.Injectable\nimport io.github.yhpgi.yoke.sample.domain.AnalyticsService\n\n@Injectable\n@ContributesTo(AppComponent::class)\nclass ListItemFormatter(\n    private val analyticsService: AnalyticsService, // Dari DI\n    @Assisted private val prefix: String,           // Diberikan saat runtime\n    @Assisted private val id: Int,                  // Diberikan saat runtime\n) {\n    // ...\n}\n</code></pre>"},{"location":"core-concepts/assisted-injection/#mendefinisikan-factory","title":"Mendefinisikan Factory","text":"<p>Selanjutnya, Anda perlu mendefinisikan sebuah <code>interface</code> <code>Factory</code> di dalam kelas tersebut.</p> <ul> <li>Nama <code>interface</code> harus tepat <code>Factory</code>.</li> <li><code>interface</code> harus memiliki satu fungsi, yang biasanya bernama <code>create</code>.</li> <li>Fungsi <code>create</code> harus mengembalikan instance dari kelas yang melingkupinya (<code>ListItemFormatter</code>).</li> <li>Parameter dari fungsi <code>create</code> harus cocok persis (dalam urutan dan tipe) dengan parameter <code>@Assisted</code> di konstruktor.</li> </ul> <pre><code>@Injectable\n@ContributesTo(AppComponent::class)\nclass ListItemFormatter(\n    private val analyticsService: AnalyticsService,\n    @Assisted private val prefix: String,\n    @Assisted private val id: Int,\n) {\n    fun format(): String {\n        analyticsService.trackEvent(\"formatListItem\")\n        return \"$prefix: Item ID #$id has been formatted.\"\n    }\n\n    // Definisikan Factory di sini\n    interface Factory {\n        fun create(prefix: String, id: Int): ListItemFormatter\n    }\n}\n</code></pre> <p>Yoke akan secara otomatis menemukan <code>interface</code> ini dan menghasilkan implementasi untuknya.</p>"},{"location":"core-concepts/assisted-injection/#menggunakan-factory","title":"Menggunakan Factory","text":"<p>Anda tidak menginjeksi kelas dengan parameter <code>@Assisted</code> secara langsung. Sebaliknya, Anda menginjeksi <code>Factory</code>-nya.</p> <pre><code>@Injectable\n@ContributesTo(AppComponent::class)\nclass MyViewModel(\n    // Injeksi Factory, bukan ListItemFormatter\n    private val formatterFactory: ListItemFormatter.Factory\n) : ViewModel() {\n\n    fun formatAnItem() {\n        // Gunakan factory untuk membuat instance dengan parameter runtime\n        val formatter = formatterFactory.create(prefix = \"Item\", id = 123)\n        val formattedText = formatter.format()\n        println(formattedText) // -&gt; \"Item: Item ID #123 has been formatted.\"\n    }\n}\n</code></pre> <p>Dengan menginjeksi <code>Factory</code>, Anda dapat membuat sebanyak mungkin instance <code>ListItemFormatter</code> yang Anda butuhkan, masing-masing dengan data runtime yang berbeda, sambil tetap membiarkan Yoke menyediakan dependensi yang dibutuhkan (seperti <code>AnalyticsService</code>).</p>"},{"location":"core-concepts/components/","title":"Konsep Inti: Komponen","text":"<p>Komponen adalah jantung dari Yoke DI. Mereka bertindak sebagai container atau \"pabrik\" untuk dependensi Anda. Setiap komponen mendefinisikan sebuah grafik dependensi dan siklus hidupnya.</p>"},{"location":"core-concepts/components/#yokecomponent","title":"<code>@YokeComponent</code>","text":"<p>Anotasi <code>@YokeComponent</code> digunakan untuk mendefinisikan sebuah container DI. Biasanya, Anda akan memiliki setidaknya satu komponen root di aplikasi Anda.</p> <p>Sebuah komponen didefinisikan sebagai sebuah <code>interface</code>.</p> <pre><code>import io.github.yhpgi.yoke.annotation.Singleton\nimport io.github.yhpgi.yoke.annotation.YokeComponent\n\n@Singleton\n@YokeComponent\ninterface AppComponent\n</code></pre> <ul> <li>Scope: Anda dapat memberikan anotasi scope (seperti <code>@Singleton</code>) pada komponen. Ini menetapkan scope default untuk semua dependensi di dalamnya yang tidak memiliki scope sendiri.</li> </ul>"},{"location":"core-concepts/components/#yokeentrypoint","title":"<code>@YokeEntryPoint</code>","text":"<p>Anotasi ini menandai sebuah komponen sebagai titik masuk utama untuk aplikasi Anda. Yoke akan menggunakan komponen ini untuk menghasilkan Composable <code>YokeApplication</code> yang membungkus seluruh aplikasi Anda.</p> <p>Hanya boleh ada satu <code>@YokeEntryPoint</code> per aplikasi.</p> <pre><code>import io.github.yhpgi.yoke.annotation.YokeEntryPoint\n\n@YokeEntryPoint // Menandai ini sebagai komponen root utama\n@Singleton\n@YokeComponent\ninterface AppComponent\n</code></pre>"},{"location":"core-concepts/components/#yokesubcomponent","title":"<code>@YokeSubcomponent</code>","text":"<p>Subkomponen adalah komponen yang siklus hidupnya lebih pendek dan terikat pada komponen induk. Mereka berguna untuk membuat scope yang lebih terbatas, seperti sesi pengguna, alur fitur, atau layar tertentu.</p> <p>Subkomponen juga didefinisikan sebagai <code>interface</code> dan harus mewarisi <code>DIContainer</code>.</p> <pre><code>import io.github.yhpgi.yoke.annotation.Scope\nimport io.github.yhpgi.yoke.annotation.YokeSubcomponent\nimport io.github.yhpgi.yoke.di.DIContainer\n\n@Scope\nannotation class UserScope // Scope kustom\n\n@UserScope\n@YokeSubcomponent\ninterface UserComponent : DIContainer\n</code></pre>"},{"location":"core-concepts/components/#contributesto","title":"<code>@ContributesTo</code>","text":"<p>Anotasi <code>@ContributesTo</code> adalah perekat yang menghubungkan semuanya. Anotasi ini digunakan pada:</p> <ol> <li>Dependensi (<code>@Injectable</code>, <code>@Module</code>) untuk mendaftarkannya ke sebuah komponen.</li> <li>Subkomponen (<code>@YokeSubcomponent</code>) untuk mengaitkannya dengan komponen induknya.</li> </ol>"},{"location":"core-concepts/components/#menghubungkan-dependensi","title":"Menghubungkan Dependensi","text":"<pre><code>// Greeter akan tersedia di dalam AppComponent\n@Injectable\n@ContributesTo(AppComponent::class)\nclass Greeter { /* ... */ }\n</code></pre>"},{"location":"core-concepts/components/#menghubungkan-subkomponen","title":"Menghubungkan Subkomponen","text":"<pre><code>// UserComponent adalah subkomponen dari AppComponent\n@UserScope\n@YokeSubcomponent\n@ContributesTo(AppComponent::class)\ninterface UserComponent : DIContainer\n</code></pre> <p>Dengan menghubungkan <code>UserComponent</code> ke <code>AppComponent</code>, dependensi di dalam <code>UserComponent</code> dapat mengakses dependensi yang disediakan oleh <code>AppComponent</code>.</p>"},{"location":"core-concepts/injection/","title":"Konsep Inti: Injeksi Dependensi","text":"<p>Yoke DI menyediakan beberapa cara untuk mendeklarasikan dan menginjeksi dependensi, semuanya dirancang agar mudah digunakan dan type-safe.</p>"},{"location":"core-concepts/injection/#constructor-injection-dengan-injectable","title":"Constructor Injection dengan <code>@Injectable</code>","text":"<p>Cara paling umum untuk memberitahu Yoke cara membuat sebuah objek adalah dengan menandai konstruktornya dengan <code>@Injectable</code>.</p> <pre><code>@Injectable\n@ContributesTo(AppComponent::class)\nclass MyRepository(\n    private val apiService: ApiService // Yoke akan menyediakan ApiService juga\n) {\n    // ...\n}\n</code></pre> <p>Ketika Yoke perlu menyediakan <code>MyRepository</code>, ia akan mencari konstruktor <code>@Injectable</code>, melihat bahwa ia membutuhkan <code>ApiService</code>, lalu mencari cara untuk menyediakan <code>ApiService</code>, dan begitu seterusnya hingga semua dependensi terpenuhi.</p>"},{"location":"core-concepts/injection/#menginjeksi-dependensi-dengan-dsl","title":"Menginjeksi Dependensi dengan DSL","text":"<p>Yoke menyediakan API berbasis DSL yang modern dan intuitif untuk mendapatkan dependensi Anda.</p>"},{"location":"core-concepts/injection/#injectt","title":"<code>inject&lt;T&gt;()</code>","text":"<p>Di dalam Composable, gunakan <code>inject&lt;T&gt;()</code> untuk mendapatkan instance dependensi Anda. Hasilnya akan diingat (<code>remembered</code>) di seluruh recomposition.</p> <pre><code>@Composable\nfun MyScreen() {\n    val repository = inject&lt;MyRepository&gt;()\n    // ... gunakan repository\n}\n</code></pre>"},{"location":"core-concepts/injection/#injectviewmodelt","title":"<code>injectViewModel&lt;T&gt;()</code>","text":"<p>Untuk ViewModels, gunakan <code>injectViewModel&lt;T&gt;()</code>. Ini secara otomatis menangani pembuatan dan scoping ViewModel ke <code>ViewModelStoreOwner</code> yang benar.</p> <pre><code>@Injectable\n@ContributesTo(AppComponent::class)\nclass MyViewModel(\n    private val repository: MyRepository\n) : ViewModel() {\n    // ...\n}\n\n@Composable\nfun MyScreen() {\n    val viewModel = injectViewModel&lt;MyViewModel&gt;()\n    // ... gunakan viewModel\n}\n</code></pre>"},{"location":"core-concepts/injection/#binding-interface-dengan-binds","title":"Binding Interface dengan <code>@Binds</code>","text":"<p>Praktik terbaik dalam pengembangan perangkat lunak adalah bergantung pada abstraksi (interface) daripada implementasi konkret. <code>@Binds</code> memungkinkan Anda melakukan ini.</p> <p>Anda dapat menandai kelas implementasi dengan <code>@Binds</code> untuk memberitahu Yoke implementasi mana yang harus disediakan ketika sebuah interface diminta.</p> <p>1. Definisikan Interface</p> <pre><code>interface AuthRepository {\n    fun isLoggedIn(): Boolean\n}\n</code></pre> <p>2. Anotasi Implementasi</p> <pre><code>@Singleton\n@Injectable\n@Binds(to = AuthRepository::class) // Mengikat AuthRepositoryImpl ke AuthRepository\n@ContributesTo(AppComponent::class)\nclass AuthRepositoryImpl : AuthRepository {\n    override fun isLoggedIn(): Boolean = true\n}\n</code></pre> <p>3. Injeksi Interface</p> <p>Sekarang Anda dapat menginjeksi <code>AuthRepository</code> dan Yoke akan secara otomatis menyediakan <code>AuthRepositoryImpl</code>.</p> <pre><code>@Injectable\n@ContributesTo(AppComponent::class)\nclass MyViewModel(\n    private val authRepository: AuthRepository // Yoke menyediakan AuthRepositoryImpl\n) : ViewModel() {\n    // ...\n}\n</code></pre>"},{"location":"core-concepts/modules/","title":"Konsep Inti: Modul &amp; Provides","text":"<p>Terkadang, Anda tidak dapat menggunakan constructor injection dengan <code>@Injectable</code>. Ini biasanya terjadi ketika:</p> <ul> <li>Anda perlu membuat instance dari kelas yang berasal dari library eksternal (Anda tidak memiliki kodenya).</li> <li>Anda perlu melakukan konfigurasi khusus untuk membuat sebuah objek (misalnya, menggunakan pola builder).</li> <li>Anda perlu menyediakan implementasi untuk sebuah interface, dan implementasinya tidak memiliki konstruktor <code>@Injectable</code>.</li> </ul> <p>Di sinilah Modul dan <code>@Provides</code> berperan.</p>"},{"location":"core-concepts/modules/#module","title":"<code>@Module</code>","text":"<p>Modul adalah <code>object</code> Kotlin yang ditandai dengan <code>@Module</code>. Modul berfungsi sebagai wadah untuk fungsi-fungsi <code>@Provides</code>.</p> <pre><code>import io.github.yhpgi.yoke.annotation.ContributesTo\nimport io.github.yhpgi.yoke.annotation.Module\n\n@Module\n@ContributesTo(AppComponent::class) // Modul ini berkontribusi ke AppComponent\nobject DataModule {\n    // ... fungsi @Provides di sini\n}\n</code></pre> <p>Sama seperti dependensi lainnya, modul harus dikaitkan ke sebuah komponen menggunakan <code>@ContributesTo</code>.</p>"},{"location":"core-concepts/modules/#provides","title":"<code>@Provides</code>","text":"<p>Di dalam <code>@Module</code>, Anda dapat mendefinisikan fungsi yang ditandai dengan <code>@Provides</code>. Fungsi-fungsi ini memberitahu Yoke cara membuat dan menyediakan suatu dependensi.</p> <ul> <li>Tipe kembalian dari fungsi <code>@Provides</code> memberitahu Yoke tipe apa yang disediakan oleh fungsi ini.</li> <li>Parameter dari fungsi adalah dependensi yang dibutuhkan oleh fungsi itu sendiri. Yoke akan menyediakan parameter-parameter ini secara otomatis.</li> </ul>"},{"location":"core-concepts/modules/#contoh-menyediakan-library-eksternal","title":"Contoh: Menyediakan Library Eksternal","text":"<p>Misalkan Anda menggunakan library <code>Retrofit</code> dan perlu menyediakan sebuah instance.</p> <pre><code>// Kelas dari library eksternal, tidak bisa kita anotasi\nclass Retrofit private constructor(...) {\n    class Builder { /* ... */ }\n}\n\n// Modul kita\n@Module\n@ContributesTo(AppComponent::class)\nobject NetworkModule {\n\n    @Provides\n    @Singleton // Kita juga bisa memberikan scope di sini\n    fun provideRetrofitInstance(): Retrofit {\n        return Retrofit.Builder()\n            .baseUrl(\"https://api.example.com/\")\n            .build()\n    }\n}\n</code></pre>"},{"location":"core-concepts/modules/#contoh-menyediakan-dependensi-dengan-dependensi-lain","title":"Contoh: Menyediakan Dependensi dengan Dependensi Lain","text":"<p>Fungsi <code>@Provides</code> juga bisa memiliki dependensi.</p> <pre><code>@Module\n@ContributesTo(AppComponent::class)\nobject ApiModule {\n\n    // Yoke akan menyediakan 'retrofit' dari NetworkModule\n    @Provides\n    fun provideAuthApiService(retrofit: Retrofit): AuthApiService {\n        return retrofit.create(AuthApiService::class.java)\n    }\n}\n</code></pre> <p>Sekarang, setiap kali Anda meminta <code>AuthApiService</code>, Yoke akan memanggil <code>provideAuthApiService</code> dan secara otomatis menyediakan parameter <code>retrofit</code> yang dibutuhkan.</p>"},{"location":"core-concepts/qualifiers/","title":"Konsep Inti: Qualifier","text":"<p>Terkadang Anda perlu menyediakan beberapa implementasi berbeda untuk interface yang sama. Misalnya, Anda mungkin memiliki <code>UserRepository</code> untuk pengguna tamu dan satu lagi untuk pengguna premium.</p> <pre><code>interface UserRepository {\n    fun getUsername(): String\n}\n\nclass GuestUserRepositoryImpl : UserRepository { /* ... */ }\nclass PremiumUserRepositoryImpl : UserRepository { /* ... */ }\n</code></pre> <p>Jika Anda mencoba menginjeksi <code>UserRepository</code>, Yoke tidak akan tahu implementasi mana yang harus disediakan. Di sinilah Qualifier berperan. Qualifier adalah anotasi yang Anda gunakan untuk memberi label pada binding, sehingga Yoke dapat membedakannya.</p>"},{"location":"core-concepts/qualifiers/#yokequalifier","title":"<code>@YokeQualifier</code>","text":"<p>Langkah pertama adalah membuat anotasi qualifier Anda sendiri. Buat anotasi baru dan tandai dengan <code>@YokeQualifier</code>.</p> <pre><code>import io.github.yhpgi.yoke.annotation.YokeQualifier\n\n@YokeQualifier\n@Retention(AnnotationRetention.SOURCE)\nannotation class GuestUser\n\n@YokeQualifier\n@Retention(AnnotationRetention.SOURCE)\nannotation class PremiumUser\n</code></pre>"},{"location":"core-concepts/qualifiers/#qualifiedby","title":"<code>@QualifiedBy</code>","text":"<p>Selanjutnya, gunakan anotasi qualifier yang baru Anda buat untuk memberi label pada implementasi atau fungsi <code>@Provides</code> Anda menggunakan <code>@QualifiedBy</code>.</p>"},{"location":"core-concepts/qualifiers/#memberi-label-pada-implementasi-injectable","title":"Memberi Label pada Implementasi <code>@Injectable</code>","text":"<pre><code>@Injectable\n@UserScope\n@ContributesTo(UserComponent::class)\n@QualifiedBy(GuestUser::class) // Memberi label ini sebagai GuestUser\n@Binds(to = UserRepository::class)\nclass GuestUserRepositoryImpl : UserRepository {\n    override fun getUsername(): String = \"Guest User\"\n}\n\n@Injectable\n@UserScope\n@ContributesTo(UserComponent::class)\n@QualifiedBy(PremiumUser::class) // Memberi label ini sebagai PremiumUser\n@Binds(to = UserRepository::class)\nclass PremiumUserRepositoryImpl : UserRepository {\n    override fun getUsername(): String = \"Premium Member\"\n}\n</code></pre>"},{"location":"core-concepts/qualifiers/#memberi-label-pada-fungsi-provides","title":"Memberi Label pada Fungsi <code>@Provides</code>","text":"<p>Anda juga dapat menggunakan <code>@QualifiedBy</code> pada fungsi <code>@Provides</code>.</p> <pre><code>@Module\n@ContributesTo(AppComponent::class)\nobject ConfigModule {\n    @Provides\n    @QualifiedBy(ApiUrl::class)\n    fun provideApiUrl(): String = \"https://api.example.com\"\n\n    @Provides\n    @QualifiedBy(ApiKey::class)\n    fun provideApiKey(): String = \"ABC-123-XYZ\"\n}\n</code></pre>"},{"location":"core-concepts/qualifiers/#menginjeksi-dengan-qualifier","title":"Menginjeksi dengan Qualifier","text":"<p>Untuk menginjeksi dependensi yang telah diberi qualifier, gunakan parameter <code>qualifiedBy</code> di dalam DSL <code>inject</code> atau <code>injectViewModel</code>.</p>"},{"location":"core-concepts/qualifiers/#injeksi-di-composable","title":"Injeksi di Composable","text":"<pre><code>@Composable\nfun UserProfile() {\n    val guestRepo = inject&lt;UserRepository&gt; {\n        qualifiedBy(GuestUser::class)\n    }\n\n    val premiumRepo = inject&lt;UserRepository&gt; {\n        qualifiedBy(PremiumUser::class)\n    }\n\n    Text(\"Guest: ${guestRepo.getUsername()}\")\n    Text(\"Premium: ${premiumRepo.getUsername()}\")\n}\n</code></pre>"},{"location":"core-concepts/qualifiers/#injeksi-di-konstruktor","title":"Injeksi di Konstruktor","text":"<p>Anda juga dapat meminta dependensi ber-qualifier di konstruktor kelas <code>@Injectable</code> lain dengan memberi anotasi pada parameter.</p> <pre><code>@Injectable\n@ContributesTo(UserComponent::class)\nclass UserViewModel(\n    @QualifiedBy(PremiumUser::class)\n    private val userRepository: UserRepository\n) : ViewModel() {\n    // ...\n}\n</code></pre>"},{"location":"core-concepts/scoping/","title":"Konsep Inti: Scoping","text":"<p>Scoping memungkinkan Anda untuk mengontrol siklus hidup dari sebuah dependensi di dalam komponennya. Secara default, setiap kali Anda menginjeksi sebuah dependensi, Yoke akan membuat instance baru. Namun, dengan scoping, Anda bisa membuat Yoke menyimpan dan menggunakan kembali instance yang sama selama komponen tersebut aktif.</p>"},{"location":"core-concepts/scoping/#singleton","title":"<code>@Singleton</code>","text":"<p><code>@Singleton</code> adalah scope bawaan yang paling umum. Dependensi yang ditandai <code>@Singleton</code> akan dibuat sekali per komponen dan instance yang sama akan digunakan kembali untuk semua injeksi berikutnya selama komponen tersebut hidup.</p> <p>Untuk komponen root (<code>AppComponent</code>), ini berarti instance tersebut akan hidup selama aplikasi berjalan.</p> <pre><code>import io.github.yhpgi.yoke.annotation.Singleton\n\n// AuthRepositoryImpl akan menjadi singleton di dalam AppComponent\n@Singleton\n@Injectable\n@ContributesTo(AppComponent::class)\nclass AuthRepositoryImpl : AuthRepository {\n    // ...\n}\n</code></pre> <p>Anda juga bisa menggunakan <code>@Singleton</code> pada fungsi <code>@Provides</code>:</p> <pre><code>@Module\n@ContributesTo(AppComponent::class)\nobject DataModule {\n    @Provides\n    @Singleton // AnalyticsService akan menjadi singleton\n    fun provideAnalyticsService(): AnalyticsService {\n        return AnalyticsService(\"https://api.example.com\")\n    }\n}\n</code></pre>"},{"location":"core-concepts/scoping/#scope-kustom-dengan-scope","title":"Scope Kustom dengan <code>@Scope</code>","text":"<p>Anda dapat mendefinisikan anotasi scope Anda sendiri untuk mengikat siklus hidup dependensi ke subkomponen kustom. Ini sangat berguna untuk scope seperti sesi pengguna.</p> <p>1. Definisikan Anotasi Scope Buat anotasi baru dan tandai dengan <code>@Scope</code>.</p> <pre><code>import io.github.yhpgi.yoke.annotation.Scope\n\n@Scope\n@Retention(AnnotationRetention.SOURCE)\nannotation class UserScope\n</code></pre> <p>2. Terapkan Scope pada Subkomponen Gunakan anotasi scope kustom Anda pada <code>interface</code> subkomponen.</p> <pre><code>@UserScope // Mengikat siklus hidup komponen ini ke UserScope\n@YokeSubcomponent\n@ContributesTo(AppComponent::class)\ninterface UserComponent : DIContainer\n</code></pre> <p>3. Terapkan Scope pada Dependensi Sekarang, tandai dependensi yang ingin Anda batasi siklus hidupnya ke <code>UserComponent</code> dengan <code>@UserScope</code>.</p> <p><pre><code>@UserScope // UserRepository ini akan hidup selama UserComponent aktif\n@Injectable\n@ContributesTo(UserComponent::class)\nclass PremiumUserRepositoryImpl : UserRepository {\n    // ...\n}\n</code></pre> Instance <code>PremiumUserRepositoryImpl</code> akan dibuat sekali saat <code>UserComponent</code> dibuat dan akan digunakan kembali untuk semua injeksi di dalam scope tersebut. Ketika <code>UserComponent</code> dihancurkan (misalnya, saat pengguna logout), instance ini juga akan dihancurkan.</p>"},{"location":"core-concepts/scoping/#manajemen-scope-dengan-dsl-scopet","title":"Manajemen Scope dengan DSL <code>scope&lt;T&gt;{}</code>","text":"<p>Yoke menyediakan DSL <code>scope&lt;T&gt;{}</code> yang elegan untuk mengelola siklus hidup subkomponen secara deklaratif di dalam UI Compose Anda.</p> <p><pre><code>@Composable\nfun MainContent() {\n    val authRepository = inject&lt;AuthRepository&gt;()\n    val isLoggedIn by authRepository.isLoggedIn.collectAsState()\n\n    // Mengelola siklus hidup UserComponent\n    scope&lt;UserComponent&gt; {\n        // Kondisi untuk mengaktifkan scope\n        active { isLoggedIn }\n\n        // Konten yang akan ditampilkan saat scope aktif\n        whenActive {\n            // Anda bisa inject dependensi dari UserComponent di sini\n            val userViewModel = injectViewModel&lt;UserViewModel&gt;()\n            UserProfileScreen(userViewModel)\n        }\n\n        // Konten yang akan ditampilkan saat scope tidak aktif\n        whenInactive {\n            LoginScreen()\n        }\n\n        // Callback opsional saat scope diaktifkan/dinonaktifkan\n        onActivate { println(\"UserComponent DIBUAT\") }\n        onDeactivate { println(\"UserComponent DIHANCURKAN\") }\n    }\n}\n</code></pre> DSL <code>scope&lt;T&gt;{}</code> secara otomatis: - Membuat <code>UserComponent</code> ketika <code>isLoggedIn</code> menjadi <code>true</code>. - Menghancurkan <code>UserComponent</code> dan semua dependensi <code>@UserScope</code> di dalamnya ketika <code>isLoggedIn</code> menjadi <code>false</code>. - Memastikan dependensi yang tepat tersedia di dalam blok <code>whenActive</code>.</p>"}]}